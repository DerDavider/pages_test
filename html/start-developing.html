<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thermal Camera SDK: Start Developing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">DoxygenAwesomeDarkModeToggle.init()</script>
<link rel="icon" href="logoSmall.png" type="image/png" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">Thermal Camera SDK<span id="projectnumber">&#160;10.0.1</span>
   </div>
   <div id="projectbrief">SDK for Optris Thermal Cameras</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('start-developing.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Start Developing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_pages_204__start__developing"></a></p>
<h1><a class="anchor" id="autotoc_md20"></a>
Contents</h1>
<ul>
<li><a class="el" href="#start-developing-which-language-to-choose">Which Language to Choose</a></li>
<li><a class="el" href="#start-developing-toolchains">Toolchains</a><ul>
<li><a class="el" href="#start-developing-toolchains-cpp">C++</a></li>
<li><a class="el" href="#start-developing-toolchains-csharp">C#</a></li>
<li><a class="el" href="#start-developing-toolchains-python3">Python 3</a></li>
</ul>
</li>
<li><a class="el" href="#start-developing-project-integration">Project Integration</a><ul>
<li><a class="el" href="#start-developing-project-integration-cpp">C++</a></li>
<li><a class="el" href="#start-developing-project-integration-csharp">C#</a></li>
<li><a class="el" href="#start-developing-project-integration-python3">Python 3</a></li>
</ul>
</li>
<li><a class="el" href="#start-developing-public-api">Public API</a><ul>
<li><a class="el" href="#start-developing-public-api-architecture">Architecture</a></li>
<li><a class="el" href="#start-developing-public-api-retrieving-thermal-data">Retrieving Thermal Data</a></li>
<li><a class="el" href="#start-developing-public-api-creating-false-color-images">Creating False Color Images</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="start-developing-which-language-to-choose"></a>
Which Language to Choose?</h1>
<p>The SDK itself is implemented in C++ but offers bindings to other language like C# and Python 3. One of the first decisions you have to make is to choose the programming language with which you want to interact with the SDK. The bindings offer full access to the exposed C++ API. However, there are some minor omissions due to technical restrictions of the target languages. Their impact on the available feature set is negligible.</p>
<p>The following table lists some use cases as well as some downsides for each language and is by no means exhaustive:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Language   </th><th class="markdownTableHeadNone">Use Case   </th><th class="markdownTableHeadNone">Downsides    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">C++   </td><td class="markdownTableBodyNone">Lowest latency and maximum performance   </td><td class="markdownTableBodyNone">Complexity    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">C#   </td><td class="markdownTableBodyNone">GUI application development   </td><td class="markdownTableBodyNone">Minor performance penalties due to bindings    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Python 3   </td><td class="markdownTableBodyNone">Prototyping and data science   </td><td class="markdownTableBodyNone">Not suitable for high performance demands (slow function calls, global interpreter lock)   </td></tr>
</table>
<p>The bindings are automatically generated with the help of <a href="https://www.swig.org/">SWIG</a> and always consist out of the to following parts:</p>
<ul>
<li>A shared library realizing a C-style function based API that is used by the target language wrapper code to access the functionality of the SDK.</li>
<li>Wrapper code in the target language that mirrors the C++ API.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>All the symbol names of the C++ API carry over to the other languages. Thus, you can easily use the API documentation in the <a class="el" href="code.html">Code</a> section although it was generated from the C++ API.</dd></dl>
<h1><a class="anchor" id="start-developing-toolchains"></a>
Toolchains</h1>
<h2><a class="anchor" id="start-developing-toolchains-cpp"></a>
C++</h2>
<p>With C++ you first of all require a compatible compiler to translate your project into an executable or a library. With regards of your operating system the SDK supports the following compilers:</p>
<ul>
<li><b>Windows</b>: Microsoft Visual C++ Compiler (MSVC)</li>
<li><b>Linux</b>: GNU Compiler Collection with C++ frontend (gcc)</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The chosen compiler should support the <b>ISO C++ 17</b> standard.</dd></dl>
<p>In addition to the compiler you need to choose which build system you want to use. The SDK supports the following options out of the box:</p>
<ul>
<li><b>Windows</b>: CMake and Visual Studio projects</li>
<li><b>Linux</b>: CMake</li>
</ul>
<p>On Linux the native package manager <code>apt</code> will automatically install the GNU compiler and CMake as dependencies of the SDK package.</p>
<p>On Windows you can easily use either the built-in capabilities of Visual Studio or you can use CMake. Regardless of your choice you need to install the Microsoft Visual C++ compiler. Navigate to the Visual Studio <a href="https://visualstudio.microsoft.com/">website</a> and download the installer. The following descriptions are based on the freely available Community Edition 2022:</p>
<ul>
<li>Start the installer</li>
<li>Choose at least the <code>Workload</code> <code>Desktop development with C++</code> <br  />
 <img src="vs_workload_cpp.png" alt="" class="inline" title="Workload Desktop development with C++"/>    </li>
</ul>
<ul>
<li>Go to the tab <code>Individual components</code> and scroll down to the section <code>Compiler, Buildtools and Runtimes</code> and select the following additional components:<ul>
<li>MSVC v143 Buildtools</li>
<li>Windows 11 SDK</li>
<li>C++-CMake-Tools for Windows (optional)</li>
<li>Core Functions of Test Tools - Buildtools</li>
<li>C++ AddressSanitizer</li>
<li>vcpkg-Package-Manager</li>
<li>C++ ATL Support for Buildtools v143</li>
<li>C++ Modules for v143 Buildtools</li>
</ul>
</li>
<li>Deselect the <code>Visual Studio core editor</code>, if you wish to use another IDE/code editor.</li>
</ul>
<p>If you want to use CMake as the build system, you have to visit to the CMake <a href="https://cmake.org/">website</a> to download their Windows installer. Run it to install CMake on your system.</p>
<h2><a class="anchor" id="start-developing-toolchains-csharp"></a>
C Sharp</h2>
<p>The C# bindings of the SDK are generated based on the <b>.NET SDK LTS version 8.0</b>. Therefore, you need to install this SDK along with its corresponding runtime. On Linux you can conveniently to do this with the help of the native package manager <code>apt</code>. Just run the following command:</p>
<div class="fragment"><div class="line">sudo apt install dotnet-sdk-8.0 dotnet8</div>
</div><!-- fragment --><p>On Windows you can refer to the Visual Studio installer to get both the .NET SDK and runtime. Navigate to the Visual Studio <a href="https://visualstudio.microsoft.com/">website</a> and download the installer. The following descriptions are based on the freely available Community Edition 2022:</p>
<ul>
<li>Start the installer</li>
<li>Choose the <code>Workload</code> <code>.NET desktop development</code> <br  />
 <img src="vs_workload_csharp.png" alt="" class="inline" title="Workload .NET desktop development"/>    </li>
</ul>
<ul>
<li>Deselect the <code>Visual Studio core editor</code>, if you wish to use another IDE/code editor.</li>
</ul>
<h2><a class="anchor" id="start-developing-toolchains-python3"></a>
Python 3</h2>
<p>In order to use the Python 3 bindings of the SDK you require the Python 3 interpreter and the <a href="https://numpy.org/">NumPy</a> library.</p>
<p><b>Linux</b></p>
<p>On Linux the bindings are compiled against the default Python 3 and NumPy versions provided by the official APT repositories. Therefore, the recommended way to install the required dependencies is the native package manager <code>apt</code>. Run the following command:</p>
<div class="fragment"><div class="line">sudo apt install python3 python3-numpy </div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If you use different Python 3 or NumPy versions than the system defaults, then you can run into compatibility issues. They can, for example, manifest through failed imports of the native bindings library <code>_otcsdk_python</code>.</dd></dl>
<p><b>Windows</b></p>
<p>On Windows the native part of the Python 3 bindings requires <b>at least</b> the following versions of Python 3 and NumPy:</p>
<ul>
<li><b>Python</b> &gt;= 3.9</li>
<li><b>NumPy</b> &gt;= 2.0.0</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>If you fail to adhere to these version requirements the import of the binding module will fail with an error message similar to: <br  />
 <code>ImportError: DLL load failed while importing _otcsdk_python</code>.</dd></dl>
<p>Since Windows lacks a central software manager you first have to download the Python 3 installer from its <a href="https://www.python.org/">website</a>. After the installation you can use the built-in package manager <code>pip</code> to install NumPy:</p>
<div class="fragment"><div class="line">pip.exe install numpy</div>
</div><!-- fragment --><p>To manipulate and and view false color images you may need an additional library like <a href="https://pypi.org/project/opencv-python/">OpenCV</a>. You can install it with the help of the package managers:</p>
<p><b>Linux</b></p>
<div class="fragment"><div class="line">sudo apt install python3-opencv</div>
</div><!-- fragment --><p><b>Windows</b></p>
<div class="fragment"><div class="line">pip.exe install opencv-python</div>
</div><!-- fragment --><h1><a class="anchor" id="start-developing-project-integration"></a>
Project Integration</h1>
<h2><a class="anchor" id="start-developing-project-integration-cpp"></a>
C++</h2>
<p>Depending on your chosen build system, CMake or Visual Studio, you have to take a different approach.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
CMake</h3>
<p>Open your <code>CMakeLists.txt</code> file and add the following <code>find_package()</code> command to instruct CMake to locate the SDK resources:</p>
<div class="fragment"><div class="line">find_package(otcsdk REQUIRED)</div>
</div><!-- fragment --><p>Then add the library target <code>otcsdk::otcsdk</code> to the <code>target_link_library()</code> command for your build target (here named <code>myTarget</code>):</p>
<div class="fragment"><div class="line">target_link_libraries(</div>
<div class="line">  myTarget</div>
<div class="line">  PRIVATE</div>
<div class="line">    otcsdk::otcsdk</div>
<div class="line">)</div>
</div><!-- fragment --><p>In this way you build your target against the shared version of the SDK library. If you wish to link statically, use the library target <code>otcsdk::static</code> instead.</p>
<p>To compile your CMake project go to the root directory of your project, create a <code>build</code> directory and change into it:</p>
<div class="fragment"><div class="line">mkdir build</div>
<div class="line">cd build</div>
</div><!-- fragment --><p>Command CMake to generate the build files and trigger the compilation process:</p>
<div class="fragment"><div class="line">cmake ..</div>
<div class="line">cmake --build . --config Release</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You can use the <code>--parallel</code> option with the second command to speed up the compilation process. Make sure, however, that you have enough memory to support all the resulting compilation processes.</dd></dl>
<h3><a class="anchor" id="autotoc_md22"></a>
Visual Studio Project</h3>
<p>The Windows SDK installer automatically sets up the system wide environment variable <code>OTC_SDK_DIR</code> that holds the path to your chosen installation directory. You can now use this variable to conveniently setup your Visual Studio C++ project.</p>
<p>After you created a C++ project in Visual Studio open the project properties and modify the following settings:</p>
<ul>
<li><code>General</code> page<ul>
<li>Set the <code>C++ Language Standard</code> to <code>ISO C++17 Standard (/std:c++17)</code>.</li>
</ul>
</li>
<li><code>VC++ Directories</code> page<ul>
<li>Add the path <code>$(OTC_SDK_DIR)\include</code> to the <code>Include Directories</code>.</li>
<li>Add the path <code>$(OTC_SDK_DIR)\lib</code> to the <code>Library Directories</code>.</li>
</ul>
</li>
<li><code>Input</code> page of the <code>Linker</code> category<ul>
<li>Add <code>otcsdk.lib</code> to the <code>Additional Dependencies</code>.</li>
</ul>
</li>
</ul>
<p>With this setup you build your project against the dynamic version of the SDK library. If you wish to link statically against the SDK, you will have to adjust the following settings:</p>
<ul>
<li><code>Input</code> page of the <code>Linker</code> category<ul>
<li>Set the <code>Additional Dependency</code> to <code>otcsdk_static.lib</code> instead of <code>otcsdk.lib</code>.</li>
</ul>
</li>
<li><code>Preprocessor</code> page of the <code>C/C++</code> category<ul>
<li>Add <code>OTC_SDK_STATIC</code> to the <code>Preprocessor Definitions</code>.</li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The define <code>OTC_SDK_STATIC</code> ensures that the macro <code>OTC_SDK_API</code> controlling the Windows DLL symbol export and import in the SDK headers is empty. For more details on this subject refer to the <a href="https://learn.microsoft.com/en-us/cpp/build/importing-and-exporting?view=msvc-170">MSVC documentation</a>.</dd></dl>
<h2><a class="anchor" id="start-developing-project-integration-csharp"></a>
C Sharp</h2>
<p>Create a subfolder <code>classes</code> in your C# project and copy the wrapper C# classes from the SDK install directory to it. They are located in</p>
<ul>
<li><code>&lt;SDK Installation Directory&gt;\bindings\csharp\classes</code> on Windows and in</li>
<li><code>/usr/share/otcsdk/csharp/classes</code> on Linux</li>
</ul>
<p>The .NET runtime locates and loads the depended shared libraries automatically.</p>
<h2><a class="anchor" id="start-developing-project-integration-python3"></a>
Python 3</h2>
<p>To use the SDK with Python 3 you just need to import the SDK module into your code:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> optris.otcsdk <span class="keyword">as</span> otc </div>
</div><!-- fragment --><p>Nothing more needs to be done.</p>
<h1><a class="anchor" id="start-developing-public-api"></a>
Public API</h1>
<h2><a class="anchor" id="start-developing-public-api-architecture"></a>
Architecture</h2>
<p>The following UML diagram illustrates the class structure of the public SDK API. All the details about the class members are omitted to ensure it is clear and easy to understand.</p>
<div class="image">
<img src="otcsdk_user_classes.png" alt=""/>
<div class="caption">
Class diagram detailing the class structure of the public API.</div></div>
    <p>A number of design patterns are employed to make the API easy to use. They include but are not limited to</p>
<p><b>Observers</b> (red)</p>
<p>The SDK features two Observer structures. The most important one is constituted by the <code>IRImager</code> interface and the <code>IRImagerClient</code>. Each <code>IRImager</code> instance represents a single thermal camera and its interface defines how you can interact with it. By registering a child class of the <code>IRImageClient</code> with the <code>addClient()</code> method you can receive processed thermal frames, flag states and other status information. To process this data implement the corresponding callback methods defined by the <code>IRImagerClient</code> in your child class.</p>
<p>The <code>EnumerationManger</code> uses the same pattern to inform <code>EnumerationClient</code> classes of newly attached or removed devices.</p>
<p>Both client classes feature empty default implementations for the callbacks they define. Therefore, you only need to override the callbacks that you need.</p>
<p><b>Factories</b> (green)</p>
<p>Factories encapsulate the instantiation of classes. The public API features two such factories: The first one is the <code>IRImagerFactory</code> that creates objects of classes that implement the <code>IRImager</code> interface based on a provided string. By requesting a <code>native</code> instance you get an <code>IRImager</code> implementation that can interact with thermal cameras via USB and Ethernet.</p>
<p>The second factory loads a <a class="el" href="important-files.html#important-files-configuration">configuration files</a> from the given path and returns an <code>IRImagerConfig</code> object with the read configuration values.</p>
<p><b>Iterators</b> (blue)</p>
<p>The iterator classes are designed to offer a uniform and convenient way to iterate over the data values stored in <code>Frame</code>, <code>ThermalFrame</code>, <code>MeasurementField</code> and <code>Image</code> objects. However, they do not offer the best performance for this purpose particularly in programming languages that are supported via bindings.</p>
<p>For more details on efficient ways to access thermal and image data please refer to the sections <a class="el" href="#start-developing-public-api-retrieving-thermal-data">Retrieving Thermal Data</a> and <a class="el" href="#start-developing-public-api-creating-false-color-images">Creating False Color Images</a>.</p>
<p><b>Singletons</b></p>
<p>Both the <code>IRImagerFactory</code> and the <code>EnumerationManager</code> are Singletons. This means there can only be one object per class and per application. To access this object you have to call the static method <code>getInstance()</code>.</p>
<p><b>Static Classes</b></p>
<p>Apart from the design patterns there is another important class: the static <code>Sdk</code> class. It contains the <code>init()</code> method required to initialize the SDK, methods to manipulate some SDK wide behavior and access to <code>VersionInfo</code> objects holding version and build information.</p>
<h2><a class="anchor" id="start-developing-public-api-retrieving-thermal-data"></a>
Retrieving Thermal Data</h2>
<p>As illustrated in the previous section, the SDK uses an Observer pattern to relay the latest thermal data to a client. This primarily happens via the following method of the <code>IRImagerClient</code> class (C++):</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> onThermalFrame(<span class="keyword">const</span> ThermalFrame&amp; thermal, <span class="keyword">const</span> FrameMetadata&amp; meta);</div>
</div><!-- fragment --><p>The thermal data is encapsulated in an object of the <code>ThermalFrame</code> class while a <code>FrameMetadata</code> object holds its corresponding metadata. There are a few important things to note:</p>
<ul>
<li><p class="startli">The method does only provide <b>references</b> (<code>&amp;</code>) to these objects. Those will remain valid while the <code>IRImager</code> instance is connected to a device. In other words, the <code>ThermalFrame</code> and <code>FrameMetadata</code> objects remain the same while a connection is active. Their <b>content</b>, however, will be <b>constantly updated</b> and will only remain the same while the method is called. <br  />
 If you wish to use the <code>ThermalFrame</code> data or the <code>FrameMetadata</code> later on or in a different thread, you will have to make an explicit copy.</p>
<dl class="section attention"><dt>Attention</dt><dd>In C++ a simple assignment is enough. In any other language you have to use the <code>clone()</code> methods of the <code>ThermalFrame</code> and <code>FrameMetadata</code> classes to ensure an explicit copy is created.</dd></dl>
</li>
<li><p class="startli">The provided references are <code>const</code>. This means you can not manipulate the objects to which they are pointing to. You have only <b>read access</b>.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <code>const</code> qualifier is typically not mirrored in the bindings of the other supported programming languages. Thus, it may appear that you can manipulate these objects but this will certainly lead to errors.</dd></dl>
</li>
<li>Keep your method implementation <b>short</b> because no further frames are processed while it is active.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>These observations also apply to the <code>onMeasurementField()</code> and <code>onThermalFrameEvent()</code> methods of the <code>IRImagerClient</code> class.</dd></dl>
<p>The <code>ThermalFrame</code> object contains the measured temperatures for each pixel in an internal format. These values are represented by <b>unsigned 16 bit integers</b>. You can convert the internal values into degree Celsius with the help of an <code>TemperatureConverter</code> object. Retrieve it for <b>every</b> <code>ThermalFrame</code> with the <code>getConverter()</code> method.</p>
<dl class="section attention"><dt>Attention</dt><dd>Do not use <code>TemperatureConverter</code> objects that you instantiated yourself but retrieve them from <b>every</b> <code>ThermalFrame</code> you process. This is necessary because the internal values differ depending which <code>TemperaturePrecision</code> is currently active.</dd></dl>
<p>You have multiple ways to access the thermal data that is internally stored in a one-dimensional array:</p>
<ul>
<li>Use the <code>getValue()</code> methods to access the internal temperature values for individual pixels.</li>
<li>Use the <code>getTemperature()</code> methods to access the temperature in degree Celsius for individual pixels.</li>
<li>Use the <code>getConstIterator()</code> method to get an iterator that allows you iterate over the entire frame.</li>
</ul>
<p>The iterator is convenient but does not offer the best performance particularly in programming languages that are supported via bindings. The most efficient ways to access the thermal data are:</p>
<ul>
<li><b>C++</b><br  />
 Use the <code>getData()</code> method to acquire a const pointer to the internal temperature value of the first pixel. All the values are stored in one continuous section of the memory like they would in a standard C array.</li>
<li><b>C#</b><br  />
 Use the <code>copyDataTo()</code> method to copy the internal temperature values to a <code>ushort[]</code> array. Make sure it has at least the size returned by the <code>getSize()</code> method.</li>
<li><b>Python 3</b><br  />
 Use the <code>copyDataTo()</code> method to copy the internal temperature values to a two-dimensional NumPy array with the shape <code>(getWidth(), getHeight())</code> and the data type <code>uint16</code>.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>These remarks also apply to the thermal data stored in <code>MeasurementField</code> objects.</dd></dl>
<h2><a class="anchor" id="start-developing-public-api-creating-false-color-images"></a>
Creating False Color Images</h2>
<p>You can easily convert a <code>ThermalFrame</code> into a false color image with the help of an <code>ImageBuilder</code> object. The resulting images have three channels: red, blue and green. Each channel has a color depth of 8 bits. The color values are stored in a continuous one-dimensional array. When setting up the <code>ImageBuilder</code> there are few things to consider:</p>
<ul>
<li><p class="startli">The <code>ColorFormat</code> defines the sequence in which the individual color values for each pixel are stored in the image array. If set to <code>RGB</code>, the value for red will have the lowest index and the value for blue will have the highest. With <code>BGR</code> things are the other way around.</p>
<dl class="section note"><dt>Note</dt><dd>Not all libraries or programming languages may interpret <code>RGB</code> and <code>BGR</code> this way.</dd></dl>
</li>
<li>The <code>WidthAlignment</code> specifies whether the size of each row/line in the resulting image should adhere to a specific alignment. For example the <code>FourBytes</code> alignment ensures that the size of every row/line in bytes is a multiple of four. If this is not the case out of the box, padding bytes will be added at the end of each line. Some libraries depend on a certain alignment to efficiently read image data.</li>
<li>The <code>ColorPalette</code> defines with what set of colors the different temperatures are represented. Refer to the API documentation of the <code>ColorPalette</code> enum to get an idea what options are available.</li>
<li>The <code>PaletteScalingMethod</code> specifies how the <code>ColorPalette</code> gets applied to the temperature spectrum found in a <code>ThermalFrame</code>.</li>
</ul>
<p>Once the <code>ImageBuilder</code> object is set up you can set the <code>ThermalFrame</code> to convert with the <code>setThermalFrame()</code> method. Trigger the conversion with <code>convertTemperatureToPaletteImage()</code> and access the result with <code>getImage()</code>. The image data is encapsulated in an <code>Image</code> object.</p>
<dl class="section attention"><dt>Attention</dt><dd>The <code>getImage()</code> method returns only a <b>reference</b> to the <code>Image</code> object that grants <b>read access</b>. If you want to retain a copy in languages other than C++, use the <code>clone()</code> method to force an explicit copy. Keep in mind that you can not manipulate the referenced <code>Image</code> object even if the API of the bindings may suggest it.</dd></dl>
<p>You can access the image data in different ways:</p>
<ul>
<li>Use the <code>getPixel()</code> methods to get a <code>Pixel</code> object containing the color values.</li>
<li>Use the <code>getConstIterator()</code> method to get an iterator that enables you to iterate over the image pixel by pixel.</li>
</ul>
<p>The iterator is more convenient than the ones for the thermal data because you do not need to worry about the order of the color values and potential padding bytes. It shares, however, the same downsides. Therefore, the SDK provides more efficient ways to access the image data:</p>
<ul>
<li><b>C++</b><br  />
 Use the <code>getData()</code> method to acquire a const pointer to the color value array. All the values are stored in one continuous section of the memory like they would in a standard C array.</li>
<li><b>C#</b><br  />
 Use the <code>copyDataTo()</code> method to copy the color values to a <code>byte[]</code> array. Make sure it has at least the size returned by the <code>getSizeInBytes()</code> method.</li>
<li><b>Python 3</b><br  />
 Use the <code>copyDataTo()</code> method to copy the color values to a three-dimensional NumPy array with the shape <code>(getWidth(), getHeight(), 3)</code> and the data type <code>uint8</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>A downside of these more efficient ways is that you have to take care of the color value order and of potential padding bytes at the end of every image row/line yourself.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>ImageBuilder</code> offers the shortcut methods <code>copyImageDataTo()</code> and <code>getImageSizeInBytes()</code> that allow you direct access the data of the <code>Image</code> object. </dd></dl>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
